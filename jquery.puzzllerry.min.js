! function (a) {
    a.fn.puzzllerry = function (b) {
        if (!b && a(this).data("puzzllerry")) return a(this).data("puzzllerry");
        var c = {
            spacing: 0,
            orientation: "vertical",
            items: "puzzllerry-item",
            freeSpace: .4,
            animation: {
                duration: 200,
                easing: "easeInOutQuad"
            },
            open: {
                height: 3,
                width: 2
            },
            callbacks: {
                open: function () {},
                close: function () {},
                move: function () {}
            },
            closeButton: !0,
            autoplay: 4e3,
            ants: !1,
            dragging: !0,
            keyboard: !0
        };
        b = a.extend({}, c, b);
        var d = {
            shuffleArray: function (a) {
                var b, c, d = a.length;
                if (d)
                    for (; --d;) c = Math.floor(Math.random() * (d + 1)), b = a[c], a[c] = a[d], a[d] = b;
                return a
            },
            oppositeMove: function (a) {
                switch (a) {
                case "up":
                    return "down";
                case "down":
                    return "up";
                case "left":
                    return "right";
                case "right":
                    return "left"
                }
            },
            clone: function (a) {
                if (null == a || "object" != typeof a) return a;
                var b = a.constructor();
                for (var c in a) b[c] = this.clone(a[c]);
                return b
            },
            randomArrayElem: function (a) {
                return a[Math.floor(Math.random() * a.length)]
            },
            createArray: function (a, b, c) {
                c = c || 0;
                for (var d = new Array(a), e = 0; e < d.length; e++) {
                    d[e] = new Array(b);
                    for (var f = 0; f < d[e].length; f++) d[e][f] = this.clone(c)
                }
                return d
            },
            escapeMapToPath: function (a, b, c) {
                for (var h, i, j, k, d = b, e = c, f = !1, g = [], l = a[b][c][1]; !f;)
                    if (h = e - 1 >= 0 ? a[d][e - 1] : !1, i = e + 1 < a[0].length ? a[d][e + 1] : !1, j = d + 1 < a.length ? a[d + 1][e] : !1, k = d - 1 >= 0 ? a[d - 1][e] : !1, h && h[1] !== !1 && h[1] < l && (g.push("down"), l = h[1], e--), i && i[1] !== !1 && i[1] < l && (g.push("up"), l = i[1], e++), j && j[1] !== !1 && j[1] < l && (g.push("left"), l = j[1], d++), k && k[1] !== !1 && k[1] < l && (g.push("right"), l = k[1], d--), 0 == l) return g.reverse(), g
            }
        };
        a.fn.puzzel = function () {
            return a(this).data("puzzllerryPuzzel")
        }, a.fn.puzzllerryDisableSelecting = function () {
            return a(this).attr("unselectable", "on").css("user-select", "none").on("selectstart", !1)
        }, a.fn.puzzllerryRandom = function () {
            var b = Math.floor(Math.random() * a(this).length);
            return a(this).eq(b)
        };
        var e = {
            isNull: function () {
                return !0
            },
            isFree: function () {
                return !1
            }
        };
        return a(this).each(function () {
            var c = a(this),
                f = a("." + b.items, c).addClass("puzzllerry-item").each(function (b) {
                    a(this).attr("puzzllerry", b)
                }).puzzllerryDisableSelecting();
            if (f.width(f.width()).height(f.height()), b.closeButton) {
                var g = a('<div class="puzzllerry-closebtn">&#10006;</div>');
                f.append(g.clone()), a(".puzzllerry-closebtn", f).click(function (b) {
                    a(this).parent().puzzel().close(), b.stopPropagation()
                })
            }
            c.hover(function () {
                a(this).addClass("puzzllerry-container-hover");
                var b = a(this).data("puzzllerry");
                b && clearTimeout(b.hoverTimeout)
            }, function () {
                var b = a(this),
                    c = a(this).data("puzzllerry"),
                    d = c.hasOpened() ? 3e3 : 1500;
                c.hoverTimeout = setTimeout(function () {
                    b.removeClass("puzzllerry-container-hover")
                }, d)
            });
            var h = function () {
                var g, e = this;
                if (this.container = c, this.puzzles = f, b.keyboard && (f.mouseenter(function () {
                    f.removeClass("puzzllerry-keyboard-control"), a(this).addClass("puzzllerry-keyboard-control"), a(document).unbind("keydown").keydown(function (d) {
                        if (!e.blockKeyboard && !e.isAnimationInProgress()) {
                            var f = a(".puzzllerry-keyboard-control").eq(0).puzzel(),
                                g = !1;
                            return 37 == d.keyCode && (f.smartMove("left"), g = !0), 38 == d.keyCode && (f.smartMove("up"), g = !0), 39 == d.keyCode && (f.smartMove("right"), g = !0), 40 == d.keyCode && (f.smartMove("down"), g = !0), 13 == d.keyCode && f.goPuzzllerry(), g ? (e.clearMainInterval(), e.closeOpened(), e.blockKeyboard = !0, setTimeout(function () {
                                e.blockKeyboard = !1
                            }, b.animation.duration), c.addClass("puzzllerry-keyboard-moving"), clearTimeout(e.keyboardTimeout), e.keyboardTimeout = setTimeout(function () {
                                c.removeClass("puzzllerry-keyboard-moving")
                            }, 3e3), !1) : void 0
                        }
                    })
                }).eq(0).mouseenter(), c.removeClass("puzzllerry-container-hover")), b.dragging && a(document).on("mousedown.puzzllerry", ".puzzllerry-item", function (b) {
                    var c = a(this),
                        d = c.puzzel(),
                        e = d.puzzllerry,
                        f = e.container;
                    c.addClass("puzzllerry-mouse-down"), f.addClass("puzzllerry-dragging"), e.clearMainInterval();
                    var g = {
                        x: b.pageX,
                        y: b.pageY
                    };
                    a(document).unbind("mousemove.puzzllerry").on("mousemove.puzzllerry", function (a) {
                        if (!e.isAnimationInProgress()) {
                            if (e.hasOpened()) return e.closeOpened(), void 0;
                            var b = {
                                    x: a.pageX,
                                    y: a.pageY
                                },
                                c = {
                                    x: g.x - b.x,
                                    y: g.y - b.y
                                },
                                f = e.animation.distance;
                            c.x > f.x && d.smartMove("left") && (g.x -= f.x), c.x < -f.x && d.smartMove("right") && (g.x += f.x), c.y < -f.y && d.smartMove("down") && (g.y += f.y), c.y > f.y && d.smartMove("up") && (g.y -= f.y)
                        }
                    }), a(document).on("mouseup", function () {
                        a(document).unbind("mousemove.puzzllerry"), c.removeClass("puzzllerry-mouse-down"), f.removeClass("puzzllerry-dragging")
                    })
                }), b.ants) {
                    var h = e;
                    h.antsInterval = setInterval(function () {
                        return h.isAnimationInProgress() || c.hasClass("puzzllerry-container-hover") || c.hasClass("puzzllerry-keyboard-moving") || h.hasMainInterval() ? void 0 : h.hasOpened() ? (h.closeOpened(), void 0) : (f.filter(function () {
                            return a(this).puzzel().possibleMoves().length
                        }).puzzllerryRandom().puzzel().randomMove(), void 0)
                    }, 1.5 * b.animation.duration)
                }
                var k = function (h) {
                    var k = e.rows,
                        l = e.cols;
                    c.data("puzzllerry", e).removeClass("puzzllerry-disabled");
                    var m = [],
                        n = 0;
                    f.removeClass("puzzllerry-opened");
                    var o = (1 + b.freeSpace) * e.puzzelsCount();
                    if (f.css("width", "").css("height", ""), c.css("width", "").css("height", ""), e.cell = {
                        width: f.width(),
                        height: f.height()
                    }, e.animation = {
                        distance: {
                            x: e.cell.width + b.spacing,
                            y: e.cell.height + b.spacing
                        }
                    }, "horizontal" == b.orientation ? (e.rows = Math.floor(c.height() / f.height()), e.rows * f.height() + (e.rows - 1) * b.spacing > c.height() && this.rows--, e.cols = Math.floor(o / e.rows) + 1, c.height(e.rows * e.cell.height + (e.rows - 1) * b.spacing), c.width(e.cols * e.cell.width + (e.cols - 1) * b.spacing)) : (e.cols = Math.floor(c.width() / f.width()), e.cols * f.width() + (e.cols - 1) * b.spacing > c.width() && e.cols--, e.rows = Math.floor(o / e.cols) + 1, c.height(e.rows * e.cell.height + (e.rows - 1) * b.spacing), c.width(e.cols * e.cell.width + (e.cols - 1) * b.spacing)), "horizontal" == b.orientation && 1 == e.rows || "vertical" == b.orientation && 1 == e.cols) return "horizontal" == b.orientation ? f.css("width", "").css("height", "100%").css("margin", "") : f.css("width", "100%").css("height", "").css("margin", ""), c.css("width", "").css("height", ""), c.addClass("puzzllerry-disabled"), void 0;
                    if (c.removeClass("puzzllerry-disabled"), !h || l != e.cols || k != e.rows) {
                        e.clicked = {}, e.closeOpened(), e.opened = {}, e.moveFlag = !1, e.clearMainInterval(), e.mainInterval = !1, f.css({
                            width: e.cell.width,
                            height: e.cell.height,
                            padding: 0,
                            margin: 0
                        });
                        for (var p = 0; p < e.cols * e.rows; p++) p < e.puzzelsCount() ? m.push(p) : m.push(null);
                        m = d.shuffleArray(m), e.fieldsArray = new Array(e.cols);
                        for (var q = 0; q < e.fieldsArray.length; q++) {
                            e.fieldsArray[q] = new Array(e.rows);
                            for (var r = 0; r < e.fieldsArray[q].length; r++) n = q * e.fieldsArray[q].length + r, e.fieldsArray[q][r] = new i(q, r, e), null != m[n] && (g = e.field(q, r), g.puzzel = new j(g, f.eq(m[n])))
                        }
                        clearInterval(e.autoplayInterval), b.autoplay && !b.ants && setTimeout(function () {
                            f.addClass("puzzllerry-autoplay-remaining"), e.autoplayInterval = setInterval(function () {
                                if (!(e.blockAutoplay || c.hasClass("puzzllerry-container-hover") || c.hasClass("puzzllerry-dragging") || c.hasClass("puzzllerry-keyboard-moving"))) {
                                    var b = a(".puzzllerry-autoplay-remaining", c);
                                    b.length || (f.addClass("puzzllerry-autoplay-remaining"), b = a(".puzzllerry-autoplay-remaining", c));
                                    var d = Math.floor(Math.random() * b.length),
                                        g = b.eq(d);
                                    g.removeClass("puzzllerry-autoplay-remaining").puzzel().goPuzzllerry()
                                }
                            }, b.autoplay / 4)
                        }, b.autoplay / 12)
                    }
                };
                k(), a(window).resize(function () {
                    e.puzzllerryBlockResize || (k(!0), e.puzzllerryBlockResize = !0, setTimeout(function () {
                        e.puzzllerryBlockResize = !1
                    }, 200))
                })
            };
            h.prototype = {
                applyToOptions: function (c) {
                    return b = a.extend({}, b, c), this
                },
                getOptions: function () {
                    return b
                },
                isDisabled: function () {
                    return this.container.hasClass("puzzllerry-disabled")
                },
                field: function (a, b) {
                    return a >= 0 && b >= 0 && a < this.fieldsArray.length && b < this.fieldsArray[a].length ? this.fieldsArray[a][b] : e
                },
                puzzelsCount: function () {
                    return f.length
                },
                puzzel: function (d) {
                    return a("." + b.items + "[puzzllerry='" + d + "']", c)
                },
                clearMoveFlag: function () {
                    return this.moveFlag = !1, this
                },
                closeOpened: function () {
                    return a.isEmptyObject(this.opened) || (this.opened.close(), this.opened = {}), this
                },
                hasOpened: function () {
                    return !a.isEmptyObject(this.opened)
                },
                isAnimationInProgress: function () {
                    return f.filter(function () {
                        return a(this).is(":animated")
                    }).length > 0
                },
                clearMainInterval: function () {
                    return clearInterval(this.mainInterval), this.mainInterval = !1, this
                },
                hasMainInterval: function () {
                    return this.mainInterval
                },
                showInfo: function (b) {
                    var c = "";
                    switch (b) {
                    case "size":
                        c = "cols: " + this.cols + ", rows: " + this.rows + ", puzzels: " + this.puzzelsCount();
                        break;
                    case "fields":
                        for (var d = 0; d < this.rows; d++) {
                            for (var e = 0; e < this.cols; e++) c = c + (a.isEmptyObject(this.field(e, d).puzzel) ? "-" : this.field(e, d).puzzel.id) + " ";
                            c += "\n"
                        }
                        break;
                    case "reserved":
                        for (var d = 0; d < this.rows; d++) {
                            for (var e = 0; e < this.cols; e++) c = c + (this.field(e, d).isReserved ? "R" : "-") + " ";
                            c += "\n"
                        }
                    }
                    console.log(c)
                },
                hasField: function (a, b) {
                    return !this.field(a, b).isNull()
                },
                setReservedField: function (a, b, c, d) {
                    if (a + c - 1 < this.cols && b + d - 1 < this.rows) {
                        for (var e = a; a + c > e; e++)
                            for (var f = b; b + d > f; f++) this.field(e, f).isReserved = !0;
                        return this
                    }
                    return !1
                },
                setReservedPath: function (a, b, c, d) {
                    if (this.field(a, b).isNull() || this.field(c, d).isNull()) return !1;
                    for (var e = 0; e < this.cols; e++) e >= Math.min(a, c) && e <= Math.max(a, c) && (this.field(e, b).isReserved = !0);
                    for (var f = 0; f < this.rows; f++) f >= Math.min(b, d) && f <= Math.max(b, d) && (this.field(c, f).isReserved = !0);
                    return this
                },
                clearReserved: function () {
                    for (var a = 0; a < this.cols; a++)
                        for (var b = 0; b < this.rows; b++) this.field(a, b).isReserved = !1;
                    return this
                },
                allReservedFields: function () {
                    for (var b, a = [], c = 0; c < this.cols; c++)
                        for (var d = 0; d < this.rows; d++) b = this.field(c, d), b.isReserved && a.push(b);
                    return a
                },
                allFieldsWithPuzzels: function () {
                    for (var b, a = [], c = 0; c < this.cols; c++)
                        for (var d = 0; d < this.rows; d++) b = this.field(c, d), b.isFree() || a.push(b);
                    return a
                },
                allFieldsWithPuzzelsCanMove: function () {
                    for (var b, a = [], c = 0; c < this.cols; c++)
                        for (var d = 0; d < this.rows; d++) b = this.field(c, d), !b.isFree() && b.puzzel.whereCanMove() && a.push(b);
                    return a
                },
                expandReserved: function () {
                    var c, d, e, a = !0,
                        b = this.allReservedFields();
                    if (b.length) {
                        a = !1;
                        for (var f = 0; f < b.length; f++) {
                            c = b[f], d = c.neighbours();
                            for (var g = 0; g < d.length; g++) e = d[g], e.isReserved || (a = !0), e.isReserved = !0
                        }
                    }
                    return a
                },
                puzzelsOnReserved: function (a) {
                    a = a || !0;
                    for (var c, b = this.allReservedFields(), d = [], e = 0; e < b.length; e++) c = b[e], c.isFree() || (c.puzzel.isClicked() ? a || d.push(c.puzzel) : d.push(c.puzzel));
                    return d
                }
            };
            var i = function (a, b, c) {
                this.x = a, this.y = b, this.puzzllerry = c, this.isReserved = !1, this.puzzel = {}, this.isNull = function () {
                    return !1
                }
            };
            i.prototype = {
                up: function () {
                    return this.puzzllerry.field(this.x, this.y - 1)
                },
                left: function () {
                    return this.puzzllerry.field(this.x - 1, this.y)
                },
                down: function () {
                    return this.puzzllerry.field(this.x, this.y + 1)
                },
                right: function () {
                    return this.puzzllerry.field(this.x + 1, this.y)
                },
                neighbours: function () {
                    var a = [],
                        b = this.up(),
                        c = this.down(),
                        d = this.right(),
                        e = this.left();
                    return b.isNull() || a.push(b), c.isNull() || a.push(c), d.isNull() || a.push(d), e.isNull() || a.push(e), a
                },
                neighbour: function (a) {
                    var b = !1;
                    switch (a) {
                    case "left":
                        b = this.left();
                        break;
                    case "right":
                        b = this.right();
                        break;
                    case "up":
                        b = this.up();
                        break;
                    case "down":
                        b = this.down()
                    }
                    return b && !b.isNull() ? b : !1
                },
                isFree: function (b) {
                    return b = b || !0, a.isEmptyObject(this.puzzel) && (b || !this.isReserved)
                },
                offset: function () {
                    return {
                        x: this.x * this.puzzllerry.cell.width + this.x * b.spacing,
                        y: this.y * this.puzzllerry.cell.height + this.y * b.spacing
                    }
                },
                setReserved: function () {
                    return this.isReserved = !0, this
                },
                unsetReserved: function () {
                    return this.isReserved = !1, this
                }
            };
            var j = function (a, c) {
                this.field = a, this.puzzllerry = this.field.puzzllerry, this.elem = c, this.lastMove = "", this.elem.data("puzzllerryPuzzel", this), this.elem.data("isPuzzllerryItem") ? this.elem.animate({
                    top: this.field.offset().y,
                    left: this.field.offset().x
                }, 2 * b.animation.duration, b.animation.easing) : (this.elem.data("isPuzzllerryItem", !0), this.elem.css({
                    position: "absolute",
                    top: this.field.offset().y,
                    left: this.field.offset().x
                }))
            };
            j.prototype = {
                id: function () {
                    return this.elem.attr("puzzllerry")
                },
                openInfo: function () {
                    var a = this.field.x,
                        c = this.field.y,
                        d = this.elem.data("openheight") || b.open.height,
                        e = this.elem.data("openwidth") || b.open.width;
                    d = d > this.puzzllerry.rows ? this.puzzllerry.rows : d, e = e > this.puzzllerry.cols ? this.puzzllerry.cols : e;
                    var f = Math.min(a, this.puzzllerry.cols - e),
                        g = Math.min(c, this.puzzllerry.rows - d),
                        h = e * this.puzzllerry.cell.width + (e - 1) * b.spacing,
                        i = d * this.puzzllerry.cell.height + (d - 1) * b.spacing;
                    return {
                        height: d,
                        width: e,
                        x: f,
                        y: g,
                        heightPx: i,
                        widthPx: h
                    }
                },
                isClicked: function () {
                    return a.isEmptyObject(this.puzzllerry.clicked) ? !1 : this.id() == this.puzzllerry.clicked.id()
                },
                isPlaced: function () {
                    return this.field.x == this.openInfo().x && this.field.y == this.openInfo().y ? !0 : !1
                },
                canOpen: function () {
                    if (this.isPlaced()) {
                        for (var a = this.field.x; a < this.field.x + this.openInfo().width; a++)
                            for (var b = this.field.y; b < this.field.y + this.openInfo().height; b++)
                                if (!this.puzzllerry.field(a, b).isFree() && (this.field.x != a || this.field.y != b)) return !1;
                        return !0
                    }
                    return !1
                },
                open: function () {
                    var c = this.puzzllerry,
                        d = this.elem;
                    return c.delay = !0, this.canOpen() ? (d.animate({
                        width: this.openInfo().widthPx,
                        height: this.openInfo().heightPx
                    }, b.animation.duration, b.animation.easing, function () {
                        b.callbacks.open(d), a(this).addClass("puzzllerry-opened"), c.delay = !1
                    }), this.puzzllerry.opened = this, this) : !1
                },
                close: function () {
                    var a = this.elem;
                    if (this.isOpened()) return a.animate({
                        width: this.puzzllerry.cell.width,
                        height: this.puzzllerry.cell.height
                    }, b.animation.duration, b.animation.easing, function () {
                        b.callbacks.close(a)
                    }).removeClass("puzzllerry-opened"), this.puzzllerry.opened = {}, this
                },
                isOpened: function () {
                    return this.elem.hasClass("puzzllerry-opened")
                },
                canMove: function (a, b, c) {
                    c = void 0 === c ? !0 : c, b = void 0 === b ? !0 : b;
                    var e;
                    if (c && a == d.oppositeMove(this.lastMove)) return !1;
                    switch (a) {
                    case "up":
                        e = this.field.up();
                        break;
                    case "down":
                        e = this.field.down();
                        break;
                    case "left":
                        e = this.field.left();
                        break;
                    case "right":
                        e = this.field.right()
                    }
                    return e ? e.isFree() : !1
                },
                whereCanMove: function (a, b) {
                    return b = void 0 === b ? !0 : b, a = void 0 === a ? !0 : a, this.canMove("up", a, b) ? "up" : this.canMove("down", a, b) ? "down" : this.canMove("left", a, b) ? "left" : this.canMove("right", a, b) ? "right" : !1
                },
                possibleMoves: function (a, b) {
                    b = void 0 === b ? !0 : b, a = void 0 === a ? !0 : a;
                    var c = [];
                    return this.canMove("up", a, b) && c.push("up"), this.canMove("down", a, b) && c.push("down"), this.canMove("left", a, b) && c.push("left"), this.canMove("right", a, b) && c.push("right"), c
                },
                freeMove: function (a, b) {
                    return b = void 0 === b ? !0 : b, a = void 0 === a ? !0 : a, this.whereCanMove() !== !1 && this.move(this.whereCanMove()), this
                },
                randomMove: function (a, b) {
                    b = void 0 === b ? !1 : b, a = void 0 === a ? !0 : a;
                    var c = this.possibleMoves(!0, !1),
                        d = c[Math.floor(Math.random() * c.length)];
                    return this.canMove(d) && this.move(d), this
                },
                takeField: function (a) {
                    var b = this.field,
                        c = a;
                    return c.isFree() ? (b.puzzel = {}, c.puzzel = this, this.field = c, this) : !1
                },
                move: function (a) {
                    var c;
                    switch (this.close(), a) {
                    case "up":
                        c = this.field.up(), this.elem.animate({
                            top: "-=" + this.puzzllerry.animation.distance.y
                        }, b.animation.duration, b.animation.easing);
                        break;
                    case "down":
                        c = this.field.down(), this.elem.animate({
                            top: "+=" + this.puzzllerry.animation.distance.y
                        }, b.animation.duration, b.animation.easing);
                        break;
                    case "left":
                        c = this.field.left(), this.elem.animate({
                            left: "-=" + this.puzzllerry.animation.distance.x
                        }, b.animation.duration, b.animation.easing);
                        break;
                    case "right":
                        c = this.field.right(), this.elem.animate({
                            left: "+=" + this.puzzllerry.animation.distance.x
                        }, b.animation.duration, b.animation.easing)
                    }
                    return this.lastMove = a, this.puzzllerry.moveFlag = !0, this.takeField(c)
                },
                getCloserToDirection: function (a, b, c) {
                    a = a || this.openInfo().x, b = b || this.openInfo().y, c = c || !0;
                    var d = this.field.x,
                        e = this.field.y;
                    if (a > d) {
                        if (this.canMove("right", c, !1)) return "right"
                    } else if (d > a && this.canMove("left", c, !1)) return "left";
                    if (b > e) {
                        if (this.canMove("down", c, !1)) return "down"
                    } else if (e > b && this.canMove("up", c, !1)) return "up";
                    return !1
                },
                moveToOpenTarget: function () {
                    for (; this.getCloserToDirection();) this.move(this.getCloserToDirection());
                    return this
                },
                movePath: function (a) {
                    if (a.length)
                        for (var b = 0; b < a.length; b++) this.move(a[b]);
                    return this
                },
                escapeFromReserved: function () {
                    if (this.field.isReserved) {
                        var a = this.field,
                            b = a.x,
                            c = a.y,
                            e = 0,
                            f = d.createArray(this.puzzllerry.cols, this.puzzllerry.rows, [!1, !1]);
                        f[b][c][0] = a, f[b][c][1] = e;
                        var g, h = [];
                        g = [a];
                        for (var k, l, m, n, o, i = !0, j = !1; i && !j;) {
                            i = !1, e++;
                            for (var p = 0; p < g.length; p++) {
                                m = g[p], k = m.neighbours();
                                for (var q = 0; q < k.length; q++) l = k[q], n = l.x, o = l.y, f[n][o][1] === !1 && l.isFree() && (f[n][o][0] = l, f[n][o][1] = e, h.push(l), i = !0, l.isReserved || (j = l))
                            }
                            g = h, h = []
                        }
                        return j ? this.movePath(d.escapeMapToPath(f, j.x, j.y)) : this
                    }
                    return this
                },
                smartMove: function (a) {
                    var b = this.puzzllerry;
                    if (this.canMove(a, !0, !1) && this.move(a)) return !0;
                    var c = this.field.neighbour(a);
                    if (b.clicked = this, !c) return !1;
                    for (c.setReserved(!0); !this.canMove(a, !0, !1);) {
                        for (c.setReserved(!0); !b.moveFlag;) {
                            for (var d = b.puzzelsOnReserved(), e = 0; e < d.length; e++)
                                if (d[e].escapeFromReserved(), b.moveFlag) {
                                    b.clearReserved();
                                    break
                                }
                            b.expandReserved()
                        }
                        b.moveFlag = !1
                    }
                    return this.move(a), !0
                },
                goPuzzllerry: function () {
                    var e, a = this,
                        c = a.openInfo(),
                        d = a.puzzllerry;
                    if (!(this.isOpened() || d.isDisabled() || d.delay)) {
                        d.clearMainInterval(), clearTimeout(d.autoplayUnblockTimeaout), d.blockAutoplay = !0, d.clicked = a, d.closeOpened(), d.clearReserved();
                        var f = [];
                        d.mainInterval = setInterval(function () {
                            if (!d.isAnimationInProgress()) {
                                if (a.isPlaced()) {
                                    if (a.isPlaced()) {
                                        if (a.canOpen()) return a.open(), d.clearMainInterval(), d.autoplayUnblockTimeaout = setTimeout(function () {
                                            d.blockAutoplay = !1
                                        }, b.autoplay), void 0;
                                        if (e = d.expandReserved(), d.setReservedField(a.field.x, a.field.y, c.width, c.height), f = d.puzzelsOnReserved(), f.length)
                                            for (var g = 0; g < f.length; g++)
                                                if (f[g].escapeFromReserved(), d.moveFlag) return d.clearReserved(), d.moveFlag = !1, void 0
                                    }
                                } else {
                                    if (a.moveToOpenTarget(), d.moveFlag) return d.clearReserved(), d.moveFlag = !1, void 0;
                                    if (e = d.expandReserved(), d.setReservedPath(a.field.x, a.field.y, c.x, c.y), f = d.puzzelsOnReserved(), f.length)
                                        for (var g = 0; g < f.length; g++)
                                            if (f[g].escapeFromReserved(), d.moveFlag) return d.clearReserved(), d.moveFlag = !1, void 0
                                } if (!d.moveFlag && a.isPlaced() && !a.canOpen() && !e) {
                                    if (clickedSW = a.puzzllerry.field(a.field.x - 1, a.field.y + 1), clickedNE = a.puzzllerry.field(a.field.x + 1, a.field.y - 1), !clickedSW.isNull() && !clickedSW.isFree() && clickedSW.puzzel.canMove("up", !0, !1) && clickedSW.puzzel.move("up")) return;
                                    if (!clickedNE.isNull() && !clickedNE.isFree() && clickedNE.puzzel.canMove("left", !0, !1) && clickedNE.puzzel.move("left")) return;
                                    console.log("Cant open clicked"), d.clearMainInterval()
                                }
                                d.moveFlag = !1
                            }
                        }, b.animation.duration / 10)
                    }
                }
            }, new h, f.click(function () {
                a(this).puzzel().goPuzzllerry()
            })
        })
    }
}(jQuery);